<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<style>
    @font-face {
        font-style: normal;
        font-family: a372;
        src: url("../../css/A372.0.ttf");
    }
    @font-face {
        font-style: normal;
        font-family: lisha1;
        src: url("../../css/SIMLI1.ttf");
    }
</style>
<body>
<div>
    <a href="https://www.zcool.com.cn/u/1329797" style="font-family: lisha1,serif;color: #f56c6c">图源 ·氿鲤·设计作品</a>
    <span style="font-family: a372;font-size: 30px"> 雨汐镇·当铺</span>
</div>
<img src="../../img/pawnshop/pawnshop.jpg">
<!--<div style="font-family: a372;text-align: center;width: 1276px;">这里会有一个3D空间，实现·当铺·</div>-->
<!--<div style="font-family: a372;text-align: center;width: 1276px;">有点烦，几何形状好像要一点一点地画。。。。。。。找找有没有更好的方法</div>-->
<div style="float: left; position: absolute;font-family: a372;text-align: left;word-break: break-all; width: 400px; padding-left: 5px">
    <p>有点细致，几何形状好像要一点一点地画。。。。。找找有没有更好的方法</p>
    <p>忙!今天只有材质</p>
    <p>参考别人：抖音礼物特效是平面的官方用AE，抖音视频特效肯定不开源
        <br>腾讯企鹅直播的礼物特效是3d，正在疯狂偷。。。</p>
</div>
<div id="world" style="border: 2px solid #f56c6c;width: 1276px; height: 716px; position: relative" >

</div>
<script type="text/javascript" src="../../js/three.js"></script>
<script>
    var Colors = {
        red:0xf25346,
        white:0xd8d0d1,
        brown:0x59332e,
        pink:0xF5986E,
        brownDark:0x23190f,
        blue:0x68c3c0
    };
    window.addEventListener('load', init, false);
    function init() {
        // 创建场景，相机和渲染器
        createScene();
        // 添加光源
        createLights();
        // 添加对象
        addFont();
        addShopBuilding();
        //添加监听器
        // document.addEventListener('mousemove', handleMouseMove, false);
        // document.addEventListener('touchmove',handleMouseMove, false);
        //https://www.cnblogs.com/yangmengsheng/p/5973487.html
        // 调用循环函数，在每帧更新对象的位置和渲染场景
        loop();

        // var vConsole = new VConsole();
    }

    let scene, camera, fieldOfView, aspectRatio, nearPlane,
        farPlane, HEIGHT, WIDTH, renderer, container;

    function createScene() {
        // 获得屏幕的宽和高，
        // 用它们设置相机的纵横比
        // 还有渲染器的大小
        // HEIGHT = window.innerHeight;
        // WIDTH = window.innerWidth;
        HEIGHT = 720;
        WIDTH = 1280;

        // 创建场景
        scene = new THREE.Scene();

        // 在场景中添加雾的效果；样式上使用和背景一样的颜色
        scene.fog = new THREE.Fog(0xf7d9aa, 100, 950);

        // 创建相机
        aspectRatio = WIDTH / HEIGHT;
        fieldOfView = 60;
        nearPlane = 1;
        farPlane = 10000;
        /**
         * PerspectiveCamera 透视相机
         * @param fieldOfView 视角
         * @param aspectRatio 纵横比
         * @param nearPlane 近平面
         * @param farPlane 远平面
         */
        camera = new THREE.PerspectiveCamera(
            fieldOfView,
            aspectRatio,
            nearPlane,
            farPlane
        );

        // 设置相机的位置
        camera.position.x = 0;
        camera.position.z = 200;
        camera.position.y = 100;

        // 创建渲染器
        renderer = new THREE.WebGLRenderer({
            // 在 css 中设置背景色透明显示渐变色
            alpha: true,
            // 开启抗锯齿，但这样会降低性能。
            // 不过，由于我们的项目基于低多边形的，那还好 :)
            antialias: true
        });

        // 定义渲染器的尺寸；在这里它会填满整个屏幕
        renderer.setSize(WIDTH, HEIGHT);

        // 打开渲染器的阴影地图
        renderer.shadowMap.enabled = true;

        // 在 HTML 创建的容器中添加渲染器的 DOM 元素
        container = document.getElementById('world');
        container.appendChild(renderer.domElement);

        // 监听屏幕，缩放屏幕更新相机和渲染器的尺寸
        // window.addEventListener('resize', handleWindowResize, false);
    }
    // function handleWindowResize() {
    //     // 更新渲染器的高度和宽度以及相机的纵横比
    //     HEIGHT = window.innerHeight;
    //     WIDTH = window.innerWidth;
    //     renderer.setSize(WIDTH, HEIGHT);
    //     camera.aspect = WIDTH / HEIGHT;
    //     camera.updateProjectionMatrix();
    // }

    let hemisphereLight, shadowLight;

    function createLights() {
        // 半球光就是渐变的光；
        // 第一个参数是天空的颜色，第二个参数是地上的颜色，第三个参数是光源的强度
        hemisphereLight = new THREE.HemisphereLight(0xaaaaaa,0x000000, .9);

        // 方向光是从一个特定的方向的照射
        // 类似太阳，即所有光源是平行的
        // 第一个参数是关系颜色，第二个参数是光源强度
        shadowLight = new THREE.DirectionalLight(0xffffff, .9);

        // 设置光源的方向。
        // 位置不同，方向光作用于物体的面也不同，看到的颜色也不同
        shadowLight.position.set(150, 350, 350);

        // 开启光源投影
        shadowLight.castShadow = true;

        // 定义可见域的投射阴影
        shadowLight.shadow.camera.left = -400;
        shadowLight.shadow.camera.right = 400;
        shadowLight.shadow.camera.top = 400;
        shadowLight.shadow.camera.bottom = -400;
        shadowLight.shadow.camera.near = 1;
        shadowLight.shadow.camera.far = 1000;

        // 定义阴影的分辨率；虽然分辨率越高越好，但是需要付出更加昂贵的代价维持高性能的表现。
        shadowLight.shadow.mapSize.width = 2048;
        shadowLight.shadow.mapSize.height = 2048;

        // 为了使这些光源呈现效果，只需要将它们添加到场景中
        scene.add(hemisphereLight);
        scene.add(shadowLight);
    }

    let mesh;
    function addShopBuilding() {


        mesh = new THREE.Object3D();

        // 创建机翼
        const board = new THREE.BoxGeometry(400, 80, 10, 1, 1, 1);
        const matBoard = new THREE.MeshPhongMaterial({
            color: "#c9b8a8",
            shading: THREE.FlatShading
        });
        const boardObject = new THREE.Mesh(board, matBoard);
        boardObject.castShadow = true;
        boardObject.receiveShadow = true;
        mesh.add(boardObject);

        mesh.scale.set(.25,.25,.25);
        mesh.position.y = 100;
        scene.add(mesh);
    }

    function addFont() {
        const loader = new THREE.FontLoader();
        let a32font;
        loader.load(
            // 资源URL
            '../../fonts/A37_Regular.json',

            // onLoad回调
            function ( font ) {
                // do something with the font
                // scene.add( font );
                a32font = font;
                var textGeo = new THREE.TextGeometry( '雨汐镇·当铺', {
                    font: font,
                    size: 100,
                    height: 5,
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 10,
                    bevelSize: 8,
                    bevelSegments: 5
                } );
                let meshBasicMaterial =
                    // new THREE.MeshBasicMaterial({
                    //     color: 0x972121,
                    // });
                    new THREE.MeshNormalMaterial({flatShading: true});
                var textMesh = new THREE.Mesh(textGeo, meshBasicMaterial)
                textMesh.scale.set(.5,.5,.5);
                textMesh.position.y = 50;
                textMesh.rotateY(120)
                scene.add(textMesh)
            },

            // onProgress回调
            function ( xhr ) {
                console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
            },

            // onError回调
            function ( err ) {
                console.log( 'An error happened' );
            }
        );
    }

    function handleMouseMove(event) {

        // 这里我把接收到的鼠标位置的值转换成归一化值，在-1与1之间变化
        // 这是x轴的公式:

        var tx = -1 + (event.clientX / WIDTH)*2;

        // 对于 y 轴，我们需要一个逆公式
        // 因为 2D 的 y 轴与 3D 的 y 轴方向相反

        var ty = 1 - (event.clientY / HEIGHT)*2;
        mousePos = {x:tx, y:ty};
    }

    function loop(){

        // 更新每帧
        updatePiece();

        renderer.render(scene, camera);
        requestAnimationFrame(loop);
    }

    function updatePiece() {
        mesh.rotation.y = mesh.rotation.y - Math.PI /1000;
    }
</script>
</body>
</html>
